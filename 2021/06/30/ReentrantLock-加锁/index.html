<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="从RerentrantLock的加锁，来看看AQS的相关方法实现.">
<meta property="og:type" content="article">
<meta property="og:title" content="ReentrantLock-加锁">
<meta property="og:url" content="http://yoursite.com/2021/06/30/ReentrantLock-%E5%8A%A0%E9%94%81/index.html">
<meta property="og:site_name" content="llrrbaba">
<meta property="og:description" content="从RerentrantLock的加锁，来看看AQS的相关方法实现.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-06-30T14:42:45.449Z">
<meta property="article:modified_time" content="2021-06-29T05:11:02.000Z">
<meta property="article:author" content="llrrbaba">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/06/30/ReentrantLock-加锁/"/>





  <title>ReentrantLock-加锁 | llrrbaba</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">llrrbaba</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/30/ReentrantLock-%E5%8A%A0%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="llrrbaba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="llrrbaba">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ReentrantLock-加锁</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-30T22:42:45+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>从RerentrantLock的加锁，来看看AQS的相关方法实现.</p>
<a id="more"></a>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#lock</span></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="comment">// 如果没有其他线程持有锁的话，当前线程获得锁，设置state为1</span></span><br><span class="line"><span class="comment">// 如果当前线程已经持有锁的话，由于可重入锁，state+1</span></span><br><span class="line"><span class="comment">// 如果锁被其他线程持有，当前线程进入阻塞状态(有的地方也说线程被“挂起”)，不能被CPU调度，直到获取到锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#lock</span></span><br><span class="line"><span class="comment">// 这是ReentrantLock的内部类Sync的lock方法，这里可以看到这个方法是个抽象方法，具体实现在</span></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.NonfairSync#lock 和</span></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#lock 里</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#ReentrantLock()</span></span><br><span class="line"><span class="comment">// 创建一个可重入锁，默认是非公平的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#ReentrantLock(boolean)</span></span><br><span class="line"><span class="comment">// 我们可以自行指定锁实现，是公平还是非公平的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.NonfairSync#lock</span></span><br><span class="line"><span class="comment">// 先看看非公平锁的实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 上来先尝试插队</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">      	<span class="comment">// 如果插队成功，设置java.util.concurrent.locks.AbstractOwnableSynchronizer#exclusiveOwnerThread属性</span></span><br><span class="line">      	<span class="comment">// 声称自己获得了锁</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      	<span class="comment">// 如果插队不成功，老老实实排队去</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#lock</span></span><br><span class="line"><span class="comment">// 对比上面的非公平锁，我们可以看到，公平锁，没有插队的环节，直接就是去老老实实排队去</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 1.首先尝试获取下锁，</span></span><br><span class="line">  	<span class="comment">//		1.1如果获取锁成功，执行获取锁后的操作 </span></span><br><span class="line">  	<span class="comment">// 		1.2如果没有获取锁成功，执行下边的操作</span></span><br><span class="line">  	<span class="comment">// 2.就将当前线程添加到等待队列里</span></span><br><span class="line">  	<span class="comment">// 3.执行完1和2后，也就是尝试获取锁失败，并且将当前线程添加到等待队列里后，中断自己？TODO</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.NonfairSync#tryAcquire</span></span><br><span class="line"><span class="comment">// 首先看看非公平锁的 tryAcquire 实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span></span><br><span class="line"><span class="comment">// 可以看到，这个非公平地尝试获取锁的方法，写到了Sync里，而不是NonfairSync里，</span></span><br><span class="line"><span class="comment">// 为啥嘞，因为java.util.concurrent.locks.ReentrantLock#tryLock()也是用的这个非公平的方式，尝试获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">  	<span class="comment">// 可以看到，非公平的尝试加锁操作，和非公平的加锁(java.util.concurrent.locks.ReentrantLock.NonfairSync#lock)有点类似，</span></span><br><span class="line">  	<span class="comment">// 都是上来先插个队，看看能不能拿到锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 如果state==0，尝试用CAS的方式获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">          	<span class="comment">// 如果获取锁成功后，设置独占线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">          	<span class="comment">// 并返回true，标明获取锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      	<span class="comment">// 如果当前线程就是独占线程，就给state加上acquires</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          	<span class="comment">// int 最大值是“2147483647”，如果“2147483647+1”的话，就是“-2147483648”了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      	<span class="comment">// 更新state值</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">      	<span class="comment">// 并返回true，标明获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#tryLock()</span></span><br><span class="line"><span class="comment">// 可以看到，如果直接调用tryLock的话，实现是走的非公平的版本哦</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span></span><br><span class="line"><span class="comment">// 看下FairSync的实现版本，</span></span><br><span class="line"><span class="comment">// 可以看到，在state == 0的时候，公平锁的实现比非公平锁的实现，多一个hasQueuedPredecessors的判断，仅此而已</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  	<span class="comment">// 获取公平锁的同步状态，这里会调用aqs的getState()方法</span></span><br><span class="line">  	<span class="comment">// 因为juc包下的大部分类都会用到aqs的同步状态state，来实现特定的功能</span></span><br><span class="line">  	<span class="comment">// state == 0，说明当前没有线程持有该锁</span></span><br><span class="line">  	<span class="comment">// state &gt; 0，说明当前有线程持有该锁，持有该锁的线程可能就是当前线程</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 如果当前没有线程持有该锁的话，</span></span><br><span class="line">      	<span class="comment">// 1.因为是公平锁，先到先得，所以要查看有没有比当前线程优先级高的线程在等待锁</span></span><br><span class="line">      	<span class="comment">//		1.1如果有比当前线程优先级高的线程在等待同一把锁，尝试获取锁失败，返回false</span></span><br><span class="line">      	<span class="comment">//		1.2如果没有比当前线程优先级高的线程在等待同一把锁，继续下一步操作</span></span><br><span class="line">      	<span class="comment">// 2.通过CAS的方式，去设置state，这里的acquires就是最开始的FairSync#lock方法里的acruire(1)里的1</span></span><br><span class="line">      	<span class="comment">// 3.因为ReentrantLock本身就是独占锁模式，所以，设置同步状态state成功后，要去设置下将当前线程设置为锁的owener，尝试获取锁成功，返回true，</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 这里为啥用cas设置state，下面43行setState不是直接用的set吗，有啥区别呢？</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Note that because cancellations due to interrupts and timeouts may occur at any time, </span></span><br><span class="line"><span class="comment">             * a true return does not guarantee that some other thread will acquire before the current </span></span><br><span class="line"><span class="comment">             * thread. Likewise, it is possible for another thread to win a race to enqueue </span></span><br><span class="line"><span class="comment">             * after this method has returned false, due to the queue being empty.</span></span><br><span class="line"><span class="comment">             * 这里摘一段hasQueuedPredecessors方法的注释，可以看到，在当前线程的hasQueuedPredecessors方法返回true可能							* 有两种情况，1是等待队列本身就是空的；2是当前线程对应的节点是头节点的后继节点。</span></span><br><span class="line"><span class="comment">             * 对于第一种情况，就是等待队列本身就是空的，那别的线程也可能通过addWaiter方法，然后是acquiredQueued方法，来设						 * 置state的，所以这里要用cas的方式设置state，因为真的有可能当前线程获取锁失败</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      	<span class="comment">// 走到这里，c &gt; 0, 说明当前有线程持有该锁</span></span><br><span class="line">      	<span class="comment">// 对state维护下</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      	<span class="comment">// 设置state</span></span><br><span class="line">      	<span class="comment">// 这里和上面29行就不一样了，因为这里肯定是当前线程持有锁，所以不怕并发问题，直接set就好</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到如果c==0的时候，由于当前线程还没获取到锁，设置state使用的是compareAndSetState；而current == getExclusiveOwnerThread()的时候，当前线程已经获取到锁了，修改state是安全的，设置state使用的是setState。</p>
<p><strong>多线程下操作的时候，一定要仔细想好，想明白，我们的操作是否是线程安全的？同一时刻有没有可能多个线程执行某一段代码？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#hasQueuedPredecessors</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 获取等待队列的头节点</span></span><br><span class="line">    Node t = tail; </span><br><span class="line">  	<span class="comment">// 获取等待队列的尾节点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">  	<span class="comment">// 初次看到这里，已经懵了，如果不知道这个等待队列怎么维护头尾节点，怎么初始化队列的话，可能看这里比较难受</span></span><br><span class="line">  	<span class="comment">// 可以  先跳过这里，看看aqs是怎么维护它里面的等待队列的，再回过头来👀👀</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 看完下面的addWaiter和enq方法，再来看看这里</span></span><br><span class="line">  	<span class="comment">// 1.根据下面enq方法的第12行，可以得知，除非是在第一次插入等待队列元素时，初始化头节点和尾节点，</span></span><br><span class="line">  	<span class="comment">//   才会出现这俩节点指向同一个节点的情况；h != t说明等待队列不为空，</span></span><br><span class="line">  	<span class="comment">//   如果等待队列为空，说明肯定没有比当前线程优先级高的线程在等待锁</span></span><br><span class="line">  	<span class="comment">// 2.s为头节点的后继节点，</span></span><br><span class="line">  	<span class="comment">//	 2.1如果 h != t ，并且如果头节点的后继节点为null的话，</span></span><br><span class="line">  	<span class="comment">//	    根据下面acquireQueued方法的第19行，可以得知，如果有别的线程获取到锁的话，会将h.next设置为null，</span></span><br><span class="line">  	<span class="comment">//			Node的next属性是volatile的，线程可见的，此时，尝试获取锁失败；</span></span><br><span class="line">  	<span class="comment">//	 2.2如果 h != t ，并且如果头节点的后继节点的thread是当前线程的话，尝试获取锁成功。</span></span><br><span class="line">  	<span class="comment">// 翻译翻译，就是如果</span></span><br><span class="line">  	<span class="comment">// 1.等待队列刚刚初始化(head == tail == new Node())或者等待队列为空(head == tail == null)，肯定是可以的，说明没有比当前线程等待时间更长</span></span><br><span class="line">  	<span class="comment">// 2.如果等待队列不为空，也没问题，只要头节点的后继节点不为空，并且后继节点的线程就是当前线程，也是可以的，也说明当前线程排队排到第一位了，没有比当前线程等待时间更久的线程了</span></span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	 * Returns:</span></span><br><span class="line"><span class="comment">		 * true if there is a queued thread preceding the current thread, and false if the current thread is at 		 </span></span><br><span class="line"><span class="comment">		 * the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">		 * 这里把官方对于return为true的注释粘过来，大家可以看看</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#getFirstQueuedThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Thread <span class="title">getFirstQueuedThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// handle only fast path, else relay</span></span><br><span class="line">    <span class="keyword">return</span> (head == tail) ? <span class="keyword">null</span> : fullGetFirstQueuedThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 构建一个独占模式的节点，关联当前线程</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	 * 这里粘一段Node的代码，可以看到通过 addWaiter 方法添加的独占节点，的 nextWaiter 是 null</span></span><br><span class="line"><span class="comment">  	 * static final Node EXCLUSIVE = null;</span></span><br><span class="line"><span class="comment">  	 * Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span></span><br><span class="line"><span class="comment">     *			this.nextWaiter = mode;</span></span><br><span class="line"><span class="comment">     *		this.thread = thread;</span></span><br><span class="line"><span class="comment">		 * &#125;</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">    <span class="comment">// 将pred节点指向尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 如果尾节点不是null，将新插入的节点的前驱节点指向原先的尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">      	<span class="comment">// 通过cas的方式设置新的尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">          	<span class="comment">// 如果设置新的尾节点成功，说明没有别的线程先于当前线程插入到等待队列里，并被设置为了尾节点</span></span><br><span class="line">          	<span class="comment">// 将原先的尾节点的后继节点指向新插入的节点，等待队列构成双向链表</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">          	<span class="comment">// 返回新插入的节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 代码执行到这里，只有两种情况</span></span><br><span class="line">  	<span class="comment">// 1.如果原先的尾节点就是null，说明这个同步队列(sync queue)是个空的队列</span></span><br><span class="line">  	<span class="comment">// 2.11行的compareAndSetTail没有执行成功，因为可能同时有多个线程都在尝试入队，其他线程入队成功，那当前线程入队失败，就走到这里了</span></span><br><span class="line">    enq(node);</span><br><span class="line">  	<span class="comment">// 返回新插入的节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 通过 for(;;) 的形式，实现自旋，因为下面19行的compareAndSetTail可能执行不成功，需要自旋，再次进行入队。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">// 获取原先的尾节点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">      	<span class="comment">// 如果原先的尾节点为null，说明等待队列是个空队列</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">          	<span class="comment">// 初始化等待队列，通过cas的方式设置一个头节点，这个节点是个空节点(也有管这个首节点叫哨兵节点的)，没有线程信息</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">              	<span class="comment">// 将头节点和尾节点指向同一个节点--即刚刚初始化的空节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 如果原先的尾节点不为null，说明等待队列不是空队列</span></span><br><span class="line">          	<span class="comment">// 将新插入节点的前驱节点指向原先的尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">          	<span class="comment">// 通过cas的方式设置尾节点</span></span><br><span class="line">          	<span class="comment">// 可以看到，这里只是会将新的节点设置为新的尾节点，但是并没有操作头节点，头节点永远都是一个空节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">              	<span class="comment">// 如果设置尾节点成功，说明没有别的线程先于当前线程插入到等待队列里，并被设置为了尾节点</span></span><br><span class="line">                t.next = node;</span><br><span class="line">              	<span class="comment">// 将插入节点的前驱节点，也就是原先的尾节点返回</span></span><br><span class="line">              	<span class="comment">// 走到这里，就算入队成功了，停止自旋</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued</span></span><br><span class="line"><span class="comment">// 排队等待获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">      	<span class="comment">// 又来遍历一遍等待队列</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          	<span class="comment">// 从后往前遍历</span></span><br><span class="line">          	<span class="comment">// 为啥从后往前遍历呢？</span></span><br><span class="line">          	<span class="comment">// 获取刚刚通过addWaiter插入到队列的节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          	<span class="comment">// 不断往前遍历，直到找到某一个队列的节点的前驱节点是头节点，</span></span><br><span class="line">          	<span class="comment">// 就去尝试获取锁，如果尝试获取锁成功的话，</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">              	<span class="comment">// 将头节点设置为当前节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">              	<span class="comment">// 将原先的头节点的后继节点设置为null，</span></span><br><span class="line">              	<span class="comment">// 其实就是将原先的头节点从队列中撇掉，gg了</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">              	<span class="comment">// 获取锁成功</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 走到这里，说明，当前节点的前驱节点不是头节点，</span></span><br><span class="line">          	<span class="comment">// 或者，当前节点的前驱节点是头节点，但是tryAcquire(获取同步状失败了，被插队了呗)失败了</span></span><br><span class="line">          	<span class="comment">// 如果 shouldParkAfterFailedAcquire 返回 false，那么进入自旋，再来一次，看看当前节点的前五节点有没有变成head节点</span></span><br><span class="line">          	<span class="comment">// 如果 shouldParkAfterFailedAcquire 返回 true，那么就可以调用 parkAndCheckInterrupt 将当前线程挂起了， for(;;)也就停止了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果能走到这里的话，说明，上面应该是抛出异常了</span></span><br><span class="line">      	<span class="comment">// 12行node.predecessor()及15行tryAcquire，都有可能抛出异常</span></span><br><span class="line">      	<span class="comment">// if (nextc &lt; 0) // overflow</span></span><br><span class="line">        <span class="comment">//            throw new Error("Maximum lock count exceeded");</span></span><br><span class="line">      	<span class="comment">// 上面这个异常，是tryAcquire可能会抛出的异常，一般也不会走到这里吧，走到这里，说明重入次数也太多了吧</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer.Node#waitStatus</span></span><br><span class="line"><span class="comment">// 我们这里来看下这个 等待状态</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>这里摘一段一个大佬讲的<a href="https://segmentfault.com/a/1190000015739343" target="_blank" rel="noopener">文章</a></p>
<blockquote>
<p>一共有四种状态，在独占锁锁的获取操作中，我们只用到了其中的两个——<code>CANCELLED</code>和<code>SIGNAL</code>。<br>当然，前面我们在创建节点的时候并没有给waitStatus赋值，因此每一个节点最开始的时候waitStatus的值都被初始化为0，即不属于上面任何一种状态。</p>
<p>那么<code>CANCELLED</code>和<code>SIGNAL</code>代表什么意思呢？</p>
<p><code>CANCELLED</code>状态很好理解，它表示Node所代表的当前线程已经取消了排队，即放弃获取锁了。</p>
<p><code>SIGNAL</code>这个状态就有点意思了，它不是表征当前节点的状态，而是当前节点的下一个节点的状态。<br>当一个节点的waitStatus被置为<code>SIGNAL</code>，就说明它的下一个节点（即它的后继节点）已经被挂起了（或者马上就要被挂起了），因此在当前节点释放了锁或者放弃获取锁时，如果它的waitStatus属性为<code>SIGNAL</code>，它还要完成一个额外的操作——唤醒它的后继节点。</p>
<p>有意思的是，<code>SIGNAL</code>这个状态的设置常常不是节点自己给自己设的，而是后继节点设置的，这里给大家打个比方：</p>
<p>比如说出去吃饭，在人多的时候经常要排队取号，你取到了8号，前面还有7个人在等着进去，你就和排在你前面的7号讲“哥们，我现在排在你后面，队伍这么长，估计一时半会儿也轮不到我，我去那边打个盹，一会轮到你进去了(release)或者你不想等了(cancel), 麻烦你都叫醒我”，说完，你就把他的waitStatus值设成了<code>SIGNAL</code>。</p>
<p>换个角度讲，当我们决定要将一个线程挂起之前，首先要确保自己的前驱节点的waitStatus为<code>SIGNAL</code>，这就相当于给自己设一个闹钟再去睡，这个闹钟会在恰当的时候叫醒自己，否则，如果一直没有人来叫醒自己，自己可能就一直睡到天荒地老了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#shouldParkAfterFailedAcquire</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 获取刚刚通过addWaiter插入队列的节点的前驱节点的等待状态，waitStatus</span></span><br><span class="line">  	<span class="comment">// TODO 这里又看不懂了，去看看aqs怎么维护waitStatus的，再回来👀👀</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      	<span class="comment">// 前驱节点的状态已经是SIGNAL了，说明闹钟已经设了，可以直接睡了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      	<span class="comment">// 当前节点的 ws &gt; 0, 则为 Node.CANCELLED 说明前驱节点已经取消了等待锁(由于超时或者中断等原因)</span></span><br><span class="line">        <span class="comment">// 既然前驱节点不等了, 那就继续往前找, 直到找到一个还在等待锁的节点</span></span><br><span class="line">        <span class="comment">// 然后我们跨过这些不等待锁的节点, 直接排在等待锁的节点的后面 (是不是很开心!!!)</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      	<span class="comment">// 前驱节点的状态既不是SIGNAL，也不是CANCELLED</span></span><br><span class="line">        <span class="comment">// 用CAS设置前驱节点的ws为 Node.SIGNAL，给自己定一个闹钟</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#parkAndCheckInterrupt</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 挂起当前线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  	<span class="comment">// 注意！LockSupport.park(this)执行完成后线程就被挂起了，</span></span><br><span class="line">  	<span class="comment">// 除非其他线程unpark了当前线程，或者当前线程被中断了，</span></span><br><span class="line">  	<span class="comment">// 否则代码是不会再往下执行的，后面的Thread.interrupted()也不会被执行</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer.Node#predecessor</span></span><br><span class="line"><span class="comment">// TODO 这里需要看下，啥时候，prev会是null？</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">    Node p = prev;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里做了个非空校验，但是看了下上下文，node应该不会出现为null的情况</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 既然要取消排队了，就把node里维护的线程设置为null吧</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 跳过已经取消的前驱节点，找到非 CANCELLED 的前驱节点，并连接到非 CANCELLED 的前驱节点后面</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 找到上面获取到的前驱节点的后继节点，应该注意的是，这里获得的predNext不一定是传入进来的node</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">  	<span class="comment">// </span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">  	<span class="comment">// 如果当前node就是尾节点的话</span></span><br><span class="line">  	<span class="comment">// compareAndSetTail(node, pred) 将尾节点设置为上面找到的前驱节点</span></span><br><span class="line">  	<span class="comment">// compareAndSetNext(pred, predNext, null) 将上面找到的前驱节点的后继节点设置为null</span></span><br><span class="line">  	<span class="comment">// 通过上面两步操作，就把前驱节点设置为了新的尾节点，并把前驱节点后面的 CANCELLED 的节点全部出队了</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 走到这里就说明，当前节点后面还有节点，取消当前节点的话，要看看是不是要唤醒当前节点的后继节点</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">              	<span class="comment">// 走到这里就说明，</span></span><br><span class="line">              	<span class="comment">// 1.前驱节点不是头节点，</span></span><br><span class="line">              	<span class="comment">// 2.前驱节点的 waitStatus 也已经设置为了 SIGNAL ，后继节点从挂起变为唤醒就等前驱节点招呼就好了</span></span><br><span class="line">              	<span class="comment">// 3.前驱节点线程还在，还没出队</span></span><br><span class="line">              	<span class="comment">// 4.当前节点的后继节点还没取消</span></span><br><span class="line">              	<span class="comment">// 如果上面的都满足的话，就将当前节点的后继节点挂到上面找到的前驱节点后面，等招呼就行</span></span><br><span class="line">              	<span class="comment">// 走到这个判断里(if (next != null &amp;&amp; next.waitStatus &lt;= 0))之后，如果pred == head了，应该也没关系</span></span><br><span class="line">              	<span class="comment">// acquiredQueued里会自旋，尝试判断当前节点的前驱节点是不是头节点，并尝试加锁，但是问题是谁会来唤醒这里的next节点呢？</span></span><br><span class="line">              	<span class="comment">// TODO 留个疑问</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 如果不是上面所说的条件，就将当前节点的后继节点唤醒，</span></span><br><span class="line">          	<span class="comment">// 没有意外的话，当前节点的后继节点应该还在通过parkAndCheckInterrupt()被挂起后，还歇着呢</span></span><br><span class="line">          	<span class="comment">// 这里唤醒当前节点的后继节点，让后继节点去acquiredQueued里去自旋，再次尝试获取锁去</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">      	<span class="comment">// 最后，将当前节点的后继节点指向自己，就别再引用别的节点了，就让当前节点自己孤零零待着吧，也别当谁的gc root了</span></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">    ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">     (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">    pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node next = node.next;</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        compareAndSetNext(pred, predNext, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个 <span class="keyword">if</span> 判断略复杂，拆解开看看都是啥</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. pred != head</span><br><span class="line">  前驱节点不是头节点</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL)))</span><br><span class="line">  前驱节点的 waitStatus 是 SIGNAL 或者 前驱节点不是 CANCELLED 状态，但是我们这里成功将前驱节点的 waitStatus 设置为了 SIGNAL</span><br><span class="line">  </span><br><span class="line"><span class="number">3</span>. pred.thread != <span class="keyword">null</span></span><br><span class="line">  前驱节点里维护的线程不是<span class="keyword">null</span>；看了下上下文，只有 头节点head 和 CANCELLED节点 的线程为<span class="keyword">null</span>；</span><br><span class="line">  这里说 前驱节点的线程不为<span class="keyword">null</span>，就是说前驱节点不是头节点，也不是取消等待的节点才行</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/06/30/ReentrantLock-%E9%87%8A%E6%94%BE%E9%94%81/" rel="next" title="ReentrantLock-释放锁">
                <i class="fa fa-chevron-left"></i> ReentrantLock-释放锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/04/LoadingCache%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/" rel="prev" title="LoadingCache的构建过程">
                LoadingCache的构建过程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">llrrbaba</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">llrrbaba</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>





  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
